####第六章 块与大中枢派发
第三十七条: 理解“块”这一概念
* 块是C、C++、Objective-C中的词法闭包。
* 块可以接受参数, 也可返回值。
* 块可以分配在堆或栈上, 也可以是全局的。分配在栈上的块可拷贝到堆里, 这样的话, 就和标准的Objective-C对象一样, 具备引用计数了。

第三十八条: 为常用类型的块创建 typedef
* 以typedef重新定义块类型, 可令块变量用起来更加简单。
* 定义新类型时应遵从现有的命名习惯ru, 勿使其名称与别的类型相冲突。
* 不妨为同一个块签名定义多个类型别名。如果要重构的代码使用了块类型的某个别名, 那么只需要修改相应typedef中的块签名即可，无须改动其他typedef。

第三十九条: 用handle块降低代码分散程度
* 在创建对象时, 可以使用内联的handler块将相关业务逻辑一起声明。
* 在有多个实例需要监控时，如果采用委托模式，那么经常需要根据传入的对象来切换，而若改用handler块来实现，则可直接将块与相关对象放在一起。
* 设计API时如果用到了handler块, 那么可以增加一个参数, 使调用者可以通过此参数来决定应该把块安排在哪个队列上执行。

第四十条: 用块引用其所属对象时不要出现保留环
*如果所捕获的对象直接或者间接地保留了块本身,那就得当心保留环的问题。
*一定要找个适当的时机解除保留环,而不能把责任推给API的调用者。

第四十一条: 多用派发队列，少用同步锁
*派发队列可用来表述同步语义（synchronization semantic）,这种做法要比使用@synchronized块或NSLock对象更简单。
*将同步与异步派发结合起来,可以实现与普通加锁机制一样的同步行为,而这么做却不会阻塞执行异步派发的线程。
*使用同步队列及栏栅块，可以令同步行为更加高效。

第四十二条: 多用GCD,少用performSelector系列方法
*performSelector系列方法在内存管理方面容易有疏失。它无法确定将要执行的选择子具体是什么，因而ARC编译器也就无法插入适当的内存管理方法。
*performSelector系列方法所能处理的选择子太过局限了, 选择子的返回值类型及发送给方法的参数个数都受到限制。
*如果想把任务放在另一个线程上执行, 那么最好不要用performSelector系列方法,而是应该把任务封装到块里, 然后调用大中枢派发机制的相关方法来实现。

第四十三条: 掌握GCD及操作队列的使用时机
*在解决多线程与任务管理问题时,派发队列并非唯一方案。
*操作队列提供了一套高层的Objective-C API,能实现纯GCD所具备的绝大部分功能, 而且还能完成一些更为复杂的操作，那些操作若改用GCD来实现, 则需另外编写代码。

第四十四条: 通过Dispatch Group机制，根据系统资源状况来执行任务
*一系列任务可归入一个dispatch group之中。开发者可以在这组任务执行完毕时获得通知。
*通过dispatch group, 可以在并发式派发队列里同时执行多项任务。此时GCD会根据系统资源状况来调度这些并发执行的任务。开发者若自己来实现此功能，则需编写大量代码。

第四十五条: 使用dispatch_once来执行只需运行一次的线程安全代码
*经常需要编写"只需执行一次的线程安全代码"(thread-safe single-code execution)。通过GCD所提供的dispatch_once函数，很容易就能实现此功能。
*标记应该声明在static或global作用域中,这样的话,在把只需执行一次的块传给dispatch_once函数时,传进去的标记也是相同的。

第四十六条: 不要使用dispatch_get_current_queue
*dispatch_get_current_queue函数的行为常常与开发者所预期的不同。此函数已经废弃,只应做调试之用。
*由于派发队列是按层级来组织的,所以无法单用某个队列对象来描述"当前队列"这一概念。
*dispatch_get_current_queue函数用于解决由不可重人的代码所引发的死锁,然而能用此函数解决的问题,通常也能改用"队列特定数据"来解决。


