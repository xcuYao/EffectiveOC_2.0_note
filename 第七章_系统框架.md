#### 第七章 系统框架

第四十七条: 熟悉系统框架
>* 许多系统框架都可以直接使用。其中最重要的是Foundation与CoreFoundation,这两个框架提供了构建应用程序所需的许多核心功能。
* 很多常见任务都能用框架来做,例如音频与视频处理、网络通信、数据管理等。
* 请记住:用纯C写成的框架与用Objective-C写成的一样重要,若想成为优秀的Objective-C开发者,应该掌握C语言的核心概念。

第四十八条: 多用块枚举，少用for循环
>* 遍历collection有四种方式。最基本的办法是for循环, 其次是NSEnumerator遍历法及快速遍历法,最新、最先进的方式则是"块枚举法"。
>* “块枚举法”本身就能通过GCD来并发执行遍历操作,无须另行编写代码。而采用其他遍历方式则无法轻易实现这一点。
>* 若提前知道待遍历的collection含有何种对象，则应修改块签名，指出对象的具体类型。

第四十九条: 对自定义其内存管理语义的collection使用无缝桥接
>* 通过无缝桥接技术，可以在Foundation框架中的Objective-C对象与CoreFoundation框架中的C语言数据结构之间来回转换。
>* 在CoreFoundation层面创建collection时,可以指定许多回调函数,这些函数表示此collection应如何处理其元素。然后,可运用无缝桥接技术,将其转换成具备特殊内存管理语义的Objective-C collection。

第五十条: 构建缓存时选用NSCache而非NSDictionary
>* 实现缓存时应选用NSCache而非NSDictionary对象。因为NSCache 可以提供优雅的自动删减功能,而且是"线程安全的",此外,它与字典不同,并不会拷贝键。
>* 可以给NSCache对象设施上限,用以限制缓存中的对象总个数及“总成本”,而这些尺度则定义了缓存删减其中对象的时机。但是绝对不要把这些尺度当成可靠的“硬限制”（hard limit）,它们仅对NSCache起指导作用。
>* 将NSPurgeableData与NSCache搭配使用,可实现自动清除数据功能,也就是说,当NSPurgeableData对象所占内存为系统所丢弃时, 该对象自身也会从缓存中移除。
>* 如果缓存使用得当, 那么应用程序的响应速度就能提高。只有那种"重新计算起来很费事的"数据，才值得放入缓存,比如那些需要从网络获取或从磁盘读取的数据。

第五十一条: 精简initialize 与load的实现代码
>* 在加载阶段,如果类实现了load方法,那么系统就会调用它。分类里也可以定义此方法, 类的load方法要比分类中的首先调用。与其他方法不同,load方法不参与覆写机制。
>* 首次使用某个分类之前, 系统会向其发送initialize消息。由于此方法遵从普通的覆写规则,所以通常应该在里边判断当前要初始化的是哪个类。
>* load与initialize方法都应该实现得精简一些,这是有助于保持应用程序的响应能力,也能减少引入“依赖环(interdependdency cycle)” 的几率。
>* 无法在编译期设定的全局常量，可以放在initialize方法里初始化。

第五十二条: 别忘了NSTimer会保留其目标对象
>* NSTimer对象会保留其目标, 直到计时器本身失效为止, 调用invalidate方法可令计时器实效,另外,一次性的计时器在触发完任务之后也会失效。
>* 反复执行任务的计时器(repeating timer), 很容易引入保留环,如果这种计时器的目标对象又保留了计时器本身,那肯定会导致保留环。这种环状保留关系, 可能是自己发生的, 也可能是通过对象图里的其他对象间接发生的。
>* 可以扩充NSTimer的功能，用块来打破保留环。不过,除非NSTimer将来在公共接口里提供此功能,否则必须创建分类,将相关实现代码加入其中。